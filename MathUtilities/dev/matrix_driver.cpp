/*
 * Development test driver for the TMatrix class.
 *
 * 2013-05-29   Geoff Hayes     Initial Release.
 */

#include "TMatrix.h"
#include <iostream>
#include <limits>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#if TMATRIX_TEST_DRIVER

#define FLOAT_INPUT  0
#define DOUBLE_INPUT 1
#define DATA_PATH   "/Users/geoff/Development/cpp/workspace/MathUtilities/data/tmatrix/"
#define EPSILON     0.0000000001

// note that this value is decent for the matrices generated, but will be
// insufficient if the values within the matrix become larger espeially on the
// order of 1000 times larger than what is generated by the MATLAB test data.
// This indicates that there is a difference between the way in which MATLAB and
// the TMatrix<T> calculates the determinant.
#define DET_EPSILON 0.001

/**
 * Function to test for matrix assignment templatized on the input (from file)
 * type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixAssignmentTest(unsigned int& numTests,
                                             unsigned int& numPassed);

/**
 * Function to test for matrix copy constructor templatized on the input (from
 * file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixCopyConstructorTest(unsigned int& numTests,
                                                  unsigned int& numPassed);

/**
 * Function to test for matrix scalar assignment templatized on the input (from
 * file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixScalarAssignmentTest(unsigned int& numTests,
                                                   unsigned int& numPassed);

/**
 * Function to test for matrix scalar addition templatized on the input (from
 * file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixScalarAdditionTest(unsigned int& numTests,
                                                 unsigned int& numPassed);

/**
 * Function to test for matrix scalar subtraction templatized on the input (from
 * file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixScalarSubtractionTest(unsigned int& numTests,
                                                    unsigned int& numPassed);

/**
 * Function to test for matrix scalar multiplication templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixScalarMultiplicationTest(unsigned int& numTests,
                                                       unsigned int& numPassed);

/**
 * Function to test for matrix scalar division templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixScalarDivisionTest(unsigned int& numTests,
                                                 unsigned int& numPassed);

/**
 * Function to test for matrix addition assignment templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixAdditionAssignmentTest(unsigned int& numTests,
                                                     unsigned int& numPassed);

/**
 * Function to test for matrix addition templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixAdditionTest(unsigned int& numTests,
                                           unsigned int& numPassed);

/**
 * Function to test for matrix subtraction assignment templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixSubtractionAssignmentTest(unsigned int& numTests,
                                                        unsigned int& numPassed);

/**
 * Function to test for matrix subtraction templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixSubtractionTest(unsigned int& numTests,
                                              unsigned int& numPassed);

/**
 * Function to test for matrix multiplication assignment templatized on the
 * input (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixMultiplicationAssignmentTest(unsigned int& numTests,
                                                           unsigned int& numPassed);

/**
 * Function to test for matrix multiplication templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixMultiplicationTest(unsigned int& numTests,
                                                 unsigned int& numPassed);

/**
 * Function to test for matrix transpose templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixTransposeTest(unsigned int& numTests,
                                            unsigned int& numPassed);

/**
 * Function to test for matrix determinant templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixDeterminantTest(unsigned int& numTests,
                                              unsigned int& numPassed);

/**
 * Function to test for matrix inverse templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixInverseTest(unsigned int& numTests,
                                          unsigned int& numPassed);

/**
 * Function to test for matrix LUP templatized on the input
 * (from file) type.
 *
 * @param   numTests  The number of tests that have been executed.
 * @param   numPassed The number of tests that have passed.
 */
template <class T> void matrixLUPTest(unsigned int& numTests,
                                      unsigned int& numPassed);
int main()
{
    unsigned int numTests  = 0u;
    unsigned int numPassed = 0u;

    std::cout << "Testing Matrix Assignment Operator.........";

#if FLOAT_INPUT
    matrixAssignmentTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixAssignmentTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Copy Constructor............";

#if FLOAT_INPUT
    matrixCopyConstructorTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixCopyConstructorTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;


    std::cout << "Testing Matrix Scalar Assignment...........";

#if FLOAT_INPUT
    matrixScalarAssignmentTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixScalarAssignmentTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Scalar Addition.............";

#if FLOAT_INPUT
    matrixScalarAdditionTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixScalarAdditionTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Scalar Subtraction..........";

#if FLOAT_INPUT
    matrixScalarSubtractionTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixScalarSubtractionTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Scalar Multiplication.......";

#if FLOAT_INPUT
    matrixScalarMultiplicationTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixScalarMultiplicationTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Scalar Division.............";

#if FLOAT_INPUT
    matrixScalarDivisionTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixScalarDivisionTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Addition Assignment.........";

#if FLOAT_INPUT
    matrixAdditionAssignmentTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixAdditionAssignmentTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Addition....................";

#if FLOAT_INPUT
    matrixAdditionTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixAdditionTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Subtraction Assignment......";

#if FLOAT_INPUT
    matrixSubtractionAssignmentTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixSubtractionAssignmentTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Subtraction.................";

#if FLOAT_INPUT
    matrixSubtractionTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixSubtractionTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Multiplication Assignment...";

#if FLOAT_INPUT
    matrixMultiplicationAssignmentTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixMultiplicationAssignmentTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Multiplication..............";

#if FLOAT_INPUT
    matrixMultiplicationTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixMultiplicationTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Transpose...................";

#if FLOAT_INPUT
    matrixTransposeTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixTransposeTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix LUP.........................";

#if FLOAT_INPUT
    matrixLUPTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixLUPTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Determinant.................";

#if FLOAT_INPUT
    matrixDeterminantTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixDeterminantTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    std::cout << "Testing Matrix Inverse.....................";

#if FLOAT_INPUT
    matrixInverseTest<float>(numTests, numPassed);
#elif DOUBLE_INPUT
    matrixInverseTest<double>(numTests, numPassed);
#endif

    std::cout << numPassed << "/" << numTests << "\t (" <<
              static_cast<double>(numPassed)/static_cast<double>(numTests)*100.0
              << "%)" << std::endl;

    return 0;

}

template <class T> void matrixAssignmentTest(unsigned int& numTests,
                                             unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxAssignmentTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxAssignmentTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            T* data = new T[numRows*numCols];
            fread(data, sizeof(T), numRows*numCols, inputFile);

            A.copy(numRows, numCols, data);

            // test the assignment
            TMatrix<T> B = A;

            bool diffFound = false;

            for (unsigned short i=1; i<=numRows; ++i)
            {
                for (unsigned short j=1; j<=numCols; ++j)
                {
                    if(A(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixCopyConstructorTest(unsigned int& numTests,
                                                  unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxAssignmentTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxAssignmentTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            T* data = new T[numRows*numCols];
            fread(data, sizeof(T), numRows*numCols, inputFile);

            A.copy(numRows, numCols, data);

            // test the assignment
            TMatrix<T> B(A);

            bool diffFound = false;

            for (unsigned short i=1; i<=numRows; ++i)
            {
                for (unsigned short j=1; j<=numCols; ++j)
                {
                    if(A(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixScalarAssignmentTest(unsigned int& numTests,
                                                   unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxScalarAssignmentTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxScalarAssignmentTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            T data = static_cast<T>(0);

            fread(&data, sizeof(T), 1, inputFile);

            // test the scalar assignment
            A = data;

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != data)
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }
        }

        fclose(inputFile);
    }
}

template <class T> void matrixScalarAdditionTest(unsigned int& numTests,
                                                 unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxScalarAdditionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxScalarAdditionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);

            T  data1 = static_cast<T>(0);
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(&data1, sizeof(T), 1, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the scalar addition
            A.copy(numRows,numCols,data2);
            A += data1;
            B.copy(numRows,numCols,data3);

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixScalarSubtractionTest(unsigned int& numTests,
                                                    unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxScalarSubtractionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxScalarSubtractionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);

            T  data1 = static_cast<T>(0);
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(&data1, sizeof(T), 1, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the scalar subtraction
            A.copy(numRows,numCols,data2);
            A -= data1;
            B.copy(numRows,numCols,data3);

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixScalarMultiplicationTest(unsigned int& numTests,
                                                       unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxScalarMultiplicationTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxScalarMultiplicationTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);

            T  data1 = static_cast<T>(0);
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(&data1, sizeof(T), 1, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the scalar multiplication
            A.copy(numRows,numCols,data2);
            A *= data1;
            B.copy(numRows,numCols,data3);

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixScalarDivisionTest(unsigned int& numTests,
                                                 unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxScalarDivisionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxScalarDivisionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);

            T  data1 = static_cast<T>(0);
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(&data1, sizeof(T), 1, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the scalar division
            A.copy(numRows,numCols,data2);
            A /= data1;
            B.copy(numRows,numCols,data3);

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixAdditionAssignmentTest(unsigned int& numTests,
                                                     unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxAdditionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxAdditionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);
            TMatrix<T> C(numRows, numCols);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the matrix addition
            A.copy(numRows,numCols,data1);
            B.copy(numRows,numCols,data2);
            C.copy(numRows,numCols,data3);

            A += B;

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != C(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixSubtractionAssignmentTest(unsigned int& numTests,
                                                        unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxSubtractionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxSubtractionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);
            TMatrix<T> C(numRows, numCols);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the matrix subtraction
            A.copy(numRows,numCols,data1);
            B.copy(numRows,numCols,data2);
            C.copy(numRows,numCols,data3);

            A -= B;

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(A(i,j) != C(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixAdditionTest(unsigned int& numTests,
                                           unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxAdditionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxAdditionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);
            TMatrix<T> C(numRows, numCols);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the matrix addition
            A.copy(numRows,numCols,data1);
            B.copy(numRows,numCols,data2);
            C.copy(numRows,numCols,data3);

            TMatrix<T> D = A + B;

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(D(i,j) != C(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixSubtractionTest(unsigned int& numTests,
                                              unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxSubtractionTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxSubtractionTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);
            TMatrix<T> C(numRows, numCols);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);

            // test the matrix subtraction
            A.copy(numRows,numCols,data1);
            B.copy(numRows,numCols,data2);
            C.copy(numRows,numCols,data3);

            TMatrix<T> D = A - B;

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(D(i,j) != C(i,j))
                    {std::cout << "D is " << D(i,j) << " and C is " << C(i,j);
                    std::cout << std::endl;
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixMultiplicationTest(unsigned int& numTests,
                                                 unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxMultiplicationTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxMultiplicationTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows1 = 0;
            unsigned short numCols1 = 0;
            unsigned short numRows2 = 0;
            unsigned short numCols2 = 0;

            fread(&numRows1, sizeof(unsigned short), 1, inputFile);
            fread(&numCols1, sizeof(unsigned short), 1, inputFile);
            fread(&numRows2, sizeof(unsigned short), 1, inputFile);
            fread(&numCols2, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows1==0 || numCols1==0 || numRows2==0 || numCols2==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows1, numCols1);
            TMatrix<T> B(numRows2, numCols2);
            TMatrix<T> C(numRows1, numCols2);

            T* data1 = new T[numRows1*numCols1];
            T* data2 = new T[numRows2*numCols2];
            T* data3 = new T[numRows1*numCols2];

            fread(data1, sizeof(T), numRows1*numCols1, inputFile);
            fread(data2, sizeof(T), numRows2*numCols2, inputFile);
            fread(data3, sizeof(T), numRows1*numCols2, inputFile);

            // test the matrix multiplication
            A.copy(numRows1,numCols1,data1);
            B.copy(numRows2,numCols2,data2);
            C.copy(numRows1,numCols2,data3);

            TMatrix<T> D = A * B;

            bool diffFound = false;

            for (unsigned short i=1; i<=D.getRows(); ++i)
            {
                for (unsigned short j=1; j<=D.getCols(); ++j)
                {
                    if(std::abs(D(i,j) - C(i,j)) > EPSILON)
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixMultiplicationAssignmentTest(unsigned int& numTests,
                                                           unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxMultiplicationTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxMultiplicationTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows1 = 0;
            unsigned short numCols1 = 0;
            unsigned short numRows2 = 0;
            unsigned short numCols2 = 0;

            fread(&numRows1, sizeof(unsigned short), 1, inputFile);
            fread(&numCols1, sizeof(unsigned short), 1, inputFile);
            fread(&numRows2, sizeof(unsigned short), 1, inputFile);
            fread(&numCols2, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows1==0 || numCols1==0 || numRows2==0 || numCols2==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows1, numCols1);
            TMatrix<T> B(numRows2, numCols2);
            TMatrix<T> C(numRows1, numCols2);

            T* data1 = new T[numRows1*numCols1];
            T* data2 = new T[numRows2*numCols2];
            T* data3 = new T[numRows1*numCols2];

            fread(data1, sizeof(T), numRows1*numCols1, inputFile);
            fread(data2, sizeof(T), numRows2*numCols2, inputFile);
            fread(data3, sizeof(T), numRows1*numCols2, inputFile);

            // test the matrix multiplication
            A.copy(numRows1,numCols1,data1);
            B.copy(numRows2,numCols2,data2);
            C.copy(numRows1,numCols2,data3);

            A *= B;

            bool diffFound = false;

            for (unsigned short i=1; i<=A.getRows(); ++i)
            {
                for (unsigned short j=1; j<=A.getCols(); ++j)
                {
                    if(std::abs(A(i,j) - C(i,j)) > EPSILON)
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixTransposeTest(unsigned int& numTests,
                                            unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxTransposeTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxTransposeTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numCols, numRows);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);

            // test the matrix transpose
            A.copy(numRows,numCols,data1);
            B.copy(numCols,numRows,data2);

            TMatrix<T> C = A.t();

            bool diffFound = false;

            for (unsigned short i=1; i<=C.getRows(); ++i)
            {
                for (unsigned short j=1; j<=C.getCols(); ++j)
                {
                    if(C(i,j) != B(i,j))
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixDeterminantTest(unsigned int& numTests,
                                              unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxDeterminantTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxDeterminantTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            T determ = static_cast<T>(0);

            T* data1 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(&determ, sizeof(T), 1, inputFile);

            // test the matrix transpose
            A.copy(numRows,numCols,data1);

            T tmatrixDeterm = A.det();

            if (std::abs(tmatrixDeterm-determ) < DET_EPSILON)
            {
                numPassed++;
            }
            else
            {
                numPassed = numPassed + 1 -1;
            }

            delete [] data1;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixInverseTest(unsigned int& numTests,
                                          unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxInverseTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxInverseTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> B(numRows, numCols);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);

            // test the matrix inverse
            A.copy(numRows,numCols,data1);
            B.copy(numRows,numCols,data2);

            TMatrix<T> C = A.i();

            bool diffFound = false;

            for (unsigned short i=1; i<=C.getRows(); ++i)
            {
                for (unsigned short j=1; j<=C.getCols(); ++j)
                {
                    if(std::abs(C(i,j)-B(i,j))>EPSILON)
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
        }

        fclose(inputFile);
    }
}

template <class T> void matrixLUPTest(unsigned int& numTests,
                                      unsigned int& numPassed)
{
    FILE* inputFile = 0;
    std::string pathAndFile(DATA_PATH);

    numTests  = 0;
    numPassed = 0;

    char *path = getenv("TMATRIX_DATA_PATH");
    if (path != 0)
    {
        pathAndFile.clear();
        pathAndFile.append(path);
    }

#if FLOAT_INPUT
    pathAndFile.append("float/mtxLUPTest.bin");
#elif DOUBLE_INPUT
    pathAndFile.append("double/mtxLUPTest.bin");
#endif

    inputFile = fopen(pathAndFile.c_str(), "rb");

    if (inputFile==0)
    {
        std::cout << "file could not be opened!  ";
    }
    else
    {
        while (!feof(inputFile))
        {
            // read the matrix dimensions
            unsigned short numRows = 0;
            unsigned short numCols = 0;

            fread(&numRows, sizeof(unsigned short), 1, inputFile);
            fread(&numCols, sizeof(unsigned short), 1, inputFile);

            // assume if either the row or column is zero, then there is no more
            // data to read from file
            if (numRows==0 || numCols==0)
            {
                break;
            }

            // increment the test count
            numTests++;

            TMatrix<T> A(numRows, numCols);
            TMatrix<T> L(numRows, numCols);
            TMatrix<T> U(numRows, numCols);
            TMatrix<T> P(numRows, numCols);

            T* data1 = new T[numRows*numCols];
            T* data2 = new T[numRows*numCols];
            T* data3 = new T[numRows*numCols];
            T* data4 = new T[numRows*numCols];

            fread(data1, sizeof(T), numRows*numCols, inputFile);
            fread(data2, sizeof(T), numRows*numCols, inputFile);
            fread(data3, sizeof(T), numRows*numCols, inputFile);
            fread(data4, sizeof(T), numRows*numCols, inputFile);

            // test the matrix inverse
            A.copy(numRows,numCols,data1);
            L.copy(numRows,numCols,data2);
            U.copy(numRows,numCols,data3);
            P.copy(numRows,numCols,data4);

            TMatrix<T> tL(numRows,numCols);
            TMatrix<T> tU(numRows,numCols);
            TMatrix<T> tP(numRows,numCols);

            // do the LUP factorization
            A.getLUPFactorization(tL,tU,tP);

            bool diffFound = false;

            for (unsigned short i=1; i<=numRows; ++i)
            {
                for (unsigned short j=1; j<=numCols; ++j)
                {
                    if(std::abs(L(i,j)-tL(i,j))>EPSILON)
                    {
                        diffFound = true;
                        break;
                    }
                    if(std::abs(U(i,j)-tU(i,j))>EPSILON)
                    {
                        diffFound = true;
                        break;
                    }
                    if(std::abs(P(i,j)-tP(i,j))>EPSILON)
                    {
                        diffFound = true;
                        break;
                    }
                }

                if (diffFound)
                {
                    break;
                }
            }

            if (!diffFound)
            {
                numPassed++;
            }

            delete [] data1;
            delete [] data2;
            delete [] data3;
            delete [] data4;
        }

        fclose(inputFile);
    }
}

#endif
